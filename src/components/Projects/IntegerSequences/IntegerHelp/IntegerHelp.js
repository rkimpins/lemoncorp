import React from 'react'


const IntegerHelp = (props) => {
	var text = "";
	/*
	fibonacci
	non-repeating binary
	prime numbers
	levine
	levine triangle
	van eck
	*/
	switch(props.sequence) {
		case 'fibonacci':
			text = "The fibonacci sequence can be created by starting with [0, 1], and generating subsequent terms by adding the previous two together."
				+ "0 + 1 = 1 => [0, 1, 1], 1 + 1 = 2 => [0, 1, 2], 2 + 1 = 3 => [0, 1, 2, 3]"
				+ "An interesting result is that as you continue this process the ratio of the terms approaches the Golden Ratio"
				+ "Ï† = 1.6180339887498948482045868343656381177203091798057628621354486227052604628189024497072072041893911374...";
			break;
		case 'non-repeating binary':
			text = "The non-repeating binary sequence is a sequence consisting of 0's and 1's for"
			+ "which a subset of these values is never repeated three time in a row. A practical"
			+ "application of this sequence is proving that the chess rule of ending the game"
			+ "game after a series of moves is repeated three times is not sufficient to"
			+ "guarantee the game will not continue indefinitely. This sequence is generated"
			+ "by start with [1], then adding terms by fliping the bits of the current"
			+ "sequence and appending the result to the sequence. [1] + [0] = [1, 0], "
			+ "[1, 0] + [0, 1] => [1, 0, 0, 1], [1, 0, 0, 1] + [0, 1, 1, 0] => [1, 0, 0, 1, 0, 1, 1, 0]";
			break;
		case 'prime numbers':
			text = "Prime numbers are the building blocks of all numbers. A prime number is any number "
			+ "for which there are no factors. For example, 6 is not prime because we can build it up from "
			+ "the factors 2, 3, seeing as 2 * 3 = 6. Similarily 12 is not prime because we can build it up from "
			+ "4 * 3 = 12. 7 is a prime number, because we can't multiply two integers (3.5 * 2 does not "
			+ "count because 3.5 is a decimal) to equal 7. It is expensive to calculate if large numbers "
			+ "are prime because we have to check if any of the numbers smaller than it can be multiplied "
			+ "to equal it. One final note, when we divide a non-prime number into smaller building blocks "
			+ "all of which are prime, that is called prime factorization. 4 * 3 = 12 is not a prime "
			+ "factorization of 12 since 4 is not prime, but 2 * 2 * 3 = 12 IS because 2 and 3 are prime";
			break;
		case 'levine':
			text = "The Levine sequence is created by taking the sum of each row of the levine triangle. "
			+ "See Levine Triangle for more information. A side note, the memory required to compute this "
			+ "sequence grows quickly, so the number of terms generated is limited in this program."
			+ "Some of the terms as taken from The Online Encyclopedia of Integer Sequences https://oeis.org/A011784/list"
			+ "[1,2,2,3,4,7,14,42,213,2837,175450,139759600, 6837625106787,266437144916648607844, 508009471379488821444261986503540, "
			+ "37745517525533091954736701257541238885239740313139682, 5347426383812697233786139576220450142250373277499130252554080838158299886992660750432]"
			break;
		case 'levine triangle':
			text = "The levine triangle is created row by row. We start with the row [1, 1]."
			+ "From this row, we start with the last term moving backwards, and we add that "
			+ "many 1's to the next row, then 2's, then 3's and so on. From [1, 1], [1 => 2, 1 => 1] "
			+ "to get [1, 2]. From [1, 2], [1 => 2, 2 => 1 1] to get [1, 1, 2]. "
			+ "From [1, 1, 2], [1 => 3, 1 => 2, 2 => 1 1] to get [1, 1, 2, 3]. "
			+ "[1 1 1 2 2 3 4], [1 1 1 1 2 2 2 3 3 4 4 5 6 7]"
			+ "To fit this triangle into the sequence format I just combined all the rows "
			+ "and show one term at a time ignoring triangle rows";
			break;
		case 'van eck':
			text = "The Van Eck sequence is generated by starting with [0, 0]. "
			+ "Each additional term is calculated by considering the previous term. "
			+ "If that term appears somewhere in our sequence, we count the number of "
			+ "steps backward we must take to reach it and that is our new term. "
			+ "If our term has not been seen before, we just add a zero"
			+ "[0, 0], we have seen 0 before one step back, so we add 1 and get [0, 0, 1]"
			+ "[0, 0, 1], we have not seen 1 before so we add 0 and get [0, 0, 1, 0]"
			+ "[0, 0, 1 ,0], we have seen 0 before two steps back, so we add 2 and get [0, 0, 1, 0, 2]"
			+ "This continues, and you can check it works on the first 20 terms: [0, 0, 1, 0, 2, 0, 2, 2, 1, 6, 0, 5, 0, 2, 6, 5, 4, 0, 5, 3]"
			break;
		default:
			break;
	};
	return (
		<p>{text}</p>
	)
}

export default IntegerHelp;